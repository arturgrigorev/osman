<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No Tiles Map</title>
    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        #map-container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: #1a1a2e;
            overflow: hidden;
        }
        #map-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #map-canvas:active {
            cursor: grabbing;
        }
        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            pointer-events: none;
            display: none;
            max-width: 300px;
            z-index: 1000;
        }
        .tooltip.visible {
            display: block;
        }
        .tooltip-row {
            margin: 2px 0;
        }
        .tooltip-field {
            font-weight: 600;
            color: #333;
        }
        .tooltip-value {
            color: #666;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }
        #controls button {
            width: 32px;
            height: 32px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #controls button:hover {
            background: #f0f0f0;
        }
        #attribution {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 11px;
            color: #666;
            background: rgba(255,255,255,0.7);
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <canvas id="map-canvas"></canvas>
        <div id="tooltip" class="tooltip"></div>
        <div id="controls">
            <button id="zoom-in" title="Zoom in">+</button>
            <button id="zoom-out" title="Zoom out">−</button>
            <button id="fit-bounds" title="Fit to data">⊡</button>
        </div>
        
    </div>
    <script>

(function() {
    'use strict';

    // Data
    const mapData = {"points": [{"lat": 0.0, "lng": 0.0, "properties": {"name": "Origin"}, "style": {"color": "#00ff00", "radius": 12, "stroke": "#ffffff", "stroke_width": 2, "opacity": 1, "tooltip_fields": ["name"], "tooltip_template": null, "label_field": null}}, {"lat": 45.0, "lng": 90.0, "properties": {"name": "Point A"}, "style": {"color": "#00ff00", "radius": 12, "stroke": "#ffffff", "stroke_width": 2, "opacity": 1, "tooltip_fields": ["name"], "tooltip_template": null, "label_field": null}}, {"lat": -45.0, "lng": -90.0, "properties": {"name": "Point B"}, "style": {"color": "#00ff00", "radius": 12, "stroke": "#ffffff", "stroke_width": 2, "opacity": 1, "tooltip_fields": ["name"], "tooltip_template": null, "label_field": null}}], "lines": [], "polygons": []};
    const initialCenter = [0.0, 0.0];
    const initialZoom = 2;
    const dataBounds = {"min_lat": -45.0, "max_lat": 45.0, "min_lng": -90.0, "max_lng": 90.0};
    const tileUrl = null;

    // State
    let viewCenter = [...initialCenter];
    let viewZoom = initialZoom;
    let isDragging = false;
    let dragStart = null;
    let dragCenterStart = null;

    // DOM elements
    const canvas = document.getElementById('map-canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('map-container');

    // Tile cache
    const tileCache = new Map();
    const TILE_SIZE = 256;

    // Initialize
    function init() {
        resize();
        window.addEventListener('resize', resize);
        setupEvents();
        render();
    }

    function resize() {
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width * window.devicePixelRatio;
        canvas.height = rect.height * window.devicePixelRatio;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        render();
    }

    // Coordinate transforms
    function latlngToPixel(lat, lng) {
        const scale = Math.pow(2, viewZoom) * TILE_SIZE;
        const x = (lng + 180) / 360 * scale;
        const latRad = lat * Math.PI / 180;
        const y = (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * scale;

        const centerPixel = getCenterPixel();
        const canvasWidth = canvas.width / window.devicePixelRatio;
        const canvasHeight = canvas.height / window.devicePixelRatio;

        return {
            x: x - centerPixel.x + canvasWidth / 2,
            y: y - centerPixel.y + canvasHeight / 2
        };
    }

    function pixelToLatLng(px, py) {
        const centerPixel = getCenterPixel();
        const canvasWidth = canvas.width / window.devicePixelRatio;
        const canvasHeight = canvas.height / window.devicePixelRatio;

        const worldX = px + centerPixel.x - canvasWidth / 2;
        const worldY = py + centerPixel.y - canvasHeight / 2;

        const scale = Math.pow(2, viewZoom) * TILE_SIZE;
        const lng = worldX / scale * 360 - 180;
        const n = Math.PI - 2 * Math.PI * worldY / scale;
        const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));

        return { lat, lng };
    }

    function getCenterPixel() {
        const scale = Math.pow(2, viewZoom) * TILE_SIZE;
        const x = (viewCenter[1] + 180) / 360 * scale;
        const latRad = viewCenter[0] * Math.PI / 180;
        const y = (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * scale;
        return { x, y };
    }

    // Debug info element
    const debugDiv = document.createElement('div');
    debugDiv.id = 'debug-info';
    debugDiv.style.cssText = 'position:absolute;bottom:30px;left:10px;background:rgba(0,0,0,0.7);color:#0f0;font:12px monospace;padding:8px;border-radius:4px;z-index:1000;';
    container.appendChild(debugDiv);

    function updateDebugInfo() {
        const w = canvas.width / window.devicePixelRatio;
        const h = canvas.height / window.devicePixelRatio;
        const nw = pixelToLatLng(0, 0);
        const se = pixelToLatLng(w, h);
        const ne = pixelToLatLng(w, 0);
        const sw = pixelToLatLng(0, h);

        const normLng = (lng) => {
            while (lng > 180) lng -= 360;
            while (lng < -180) lng += 360;
            return lng;
        };

        debugDiv.innerHTML =
            '<b>Visible Bounds:</b><br>' +
            'NW: ' + nw.lat.toFixed(4) + ', ' + normLng(nw.lng).toFixed(4) + '<br>' +
            'NE: ' + ne.lat.toFixed(4) + ', ' + normLng(ne.lng).toFixed(4) + '<br>' +
            'SW: ' + sw.lat.toFixed(4) + ', ' + normLng(sw.lng).toFixed(4) + '<br>' +
            'SE: ' + se.lat.toFixed(4) + ', ' + normLng(se.lng).toFixed(4) + '<br>' +
            '<b>Center:</b> ' + viewCenter[0].toFixed(4) + ', ' + viewCenter[1].toFixed(4) + '<br>' +
            '<b>Zoom:</b> ' + viewZoom.toFixed(2);
    }

    // Rendering
    function render() {
        const w = canvas.width / window.devicePixelRatio;
        const h = canvas.height / window.devicePixelRatio;

        ctx.clearRect(0, 0, w, h);
        updateDebugInfo();

        if (tileUrl) {
            drawTiles(w, h);
        }

        for (const polygon of mapData.polygons) {
            drawPolygon(polygon);
        }

        for (const line of mapData.lines) {
            drawLine(line);
        }

        for (const point of mapData.points) {
            drawPoint(point);
        }
    }

    function drawTiles(w, h) {
        const centerPixel = getCenterPixel();
        const tileZoom = Math.floor(viewZoom);
        const tileScale = Math.pow(2, tileZoom);

        const fractionalScale = Math.pow(2, viewZoom - tileZoom);
        const scaledTileSize = TILE_SIZE * fractionalScale;

        const centerAtTileZoom = {
            x: centerPixel.x / fractionalScale,
            y: centerPixel.y / fractionalScale
        };

        const halfWidthInTiles = (w / 2) / scaledTileSize;
        const halfHeightInTiles = (h / 2) / scaledTileSize;
        const centerTileX = centerAtTileZoom.x / TILE_SIZE;
        const centerTileY = centerAtTileZoom.y / TILE_SIZE;

        const startX = Math.floor(centerTileX - halfWidthInTiles - 1);
        const startY = Math.floor(centerTileY - halfHeightInTiles - 1);
        const endX = Math.ceil(centerTileX + halfWidthInTiles + 1);
        const endY = Math.ceil(centerTileY + halfHeightInTiles + 1);

        for (let x = startX; x <= endX; x++) {
            for (let y = startY; y <= endY; y++) {
                if (x < 0 || y < 0 || x >= tileScale || y >= tileScale) continue;

                const tileWorldX = x * TILE_SIZE * fractionalScale;
                const tileWorldY = y * TILE_SIZE * fractionalScale;

                const tileX = tileWorldX - centerPixel.x + w / 2;
                const tileY = tileWorldY - centerPixel.y + h / 2;

                const key = tileZoom + '/' + x + '/' + y;
                let tile = tileCache.get(key);

                if (!tile) {
                    tile = new Image();
                    tile.crossOrigin = 'anonymous';
                    tile.onload = render;
                    tile.src = tileUrl.replace('{z}', tileZoom).replace('{x}', x).replace('{y}', y);
                    tileCache.set(key, tile);
                }

                if (tile.complete && tile.naturalWidth > 0) {
                    ctx.drawImage(tile, tileX, tileY, scaledTileSize, scaledTileSize);
                }
            }
        }
    }

    function drawPoint(point) {
        const pos = latlngToPixel(point.lat, point.lng);
        const style = point.style;

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, style.radius, 0, Math.PI * 2);

        ctx.fillStyle = style.color;
        ctx.globalAlpha = style.opacity;
        ctx.fill();

        if (style.stroke_width > 0) {
            ctx.strokeStyle = style.stroke;
            ctx.lineWidth = style.stroke_width;
            ctx.stroke();
        }

        ctx.globalAlpha = 1;

        if (style.label_field && point.properties[style.label_field]) {
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(point.properties[style.label_field], pos.x, pos.y - style.radius - 5);
        }
    }

    function drawLine(line) {
        if (line.coords.length < 2) return;

        const style = line.style;
        ctx.beginPath();

        const start = latlngToPixel(line.coords[0][0], line.coords[0][1]);
        ctx.moveTo(start.x, start.y);

        for (let i = 1; i < line.coords.length; i++) {
            const pos = latlngToPixel(line.coords[i][0], line.coords[i][1]);
            ctx.lineTo(pos.x, pos.y);
        }

        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.stroke_width;
        ctx.globalAlpha = style.stroke_opacity;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (style.stroke_dasharray) {
            ctx.setLineDash(style.stroke_dasharray.split(',').map(Number));
        } else {
            ctx.setLineDash([]);
        }

        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.setLineDash([]);
    }

    function drawPolygon(polygon) {
        if (polygon.rings.length === 0 || polygon.rings[0].length < 3) return;

        const style = polygon.style;
        ctx.beginPath();

        const outer = polygon.rings[0];
        const start = latlngToPixel(outer[0][0], outer[0][1]);
        ctx.moveTo(start.x, start.y);

        for (let i = 1; i < outer.length; i++) {
            const pos = latlngToPixel(outer[i][0], outer[i][1]);
            ctx.lineTo(pos.x, pos.y);
        }
        ctx.closePath();

        for (let r = 1; r < polygon.rings.length; r++) {
            const ring = polygon.rings[r];
            const holeStart = latlngToPixel(ring[0][0], ring[0][1]);
            ctx.moveTo(holeStart.x, holeStart.y);
            for (let i = 1; i < ring.length; i++) {
                const pos = latlngToPixel(ring[i][0], ring[i][1]);
                ctx.lineTo(pos.x, pos.y);
            }
            ctx.closePath();
        }

        ctx.fillStyle = style.fill;
        ctx.globalAlpha = style.fill_opacity;
        ctx.fill('evenodd');

        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.stroke_width;
        ctx.globalAlpha = style.stroke_opacity;
        ctx.stroke();

        ctx.globalAlpha = 1;
    }

    // Event handling
    function setupEvents() {
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('mouseleave', onMouseLeave);
        canvas.addEventListener('wheel', onWheel, { passive: false });

        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd);

        document.getElementById('zoom-in').addEventListener('click', () => setZoom(viewZoom + 1));
        document.getElementById('zoom-out').addEventListener('click', () => setZoom(viewZoom - 1));
        document.getElementById('fit-bounds').addEventListener('click', fitBounds);
    }

    function onMouseDown(e) {
        isDragging = true;
        dragStart = { x: e.clientX, y: e.clientY };
        dragCenterStart = [...viewCenter];
    }

    function onMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (isDragging && dragStart) {
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;

            const startLatLng = pixelToLatLng(canvas.width / 2 / window.devicePixelRatio, canvas.height / 2 / window.devicePixelRatio);
            const endLatLng = pixelToLatLng(canvas.width / 2 / window.devicePixelRatio - dx, canvas.height / 2 / window.devicePixelRatio - dy);

            viewCenter = [
                dragCenterStart[0] - (endLatLng.lat - startLatLng.lat),
                dragCenterStart[1] - (endLatLng.lng - startLatLng.lng)
            ];
            render();
        } else {
            updateTooltip(x, y);
        }
    }

    function onMouseUp() {
        isDragging = false;
        dragStart = null;
        dragCenterStart = null;
    }

    function onMouseLeave() {
        isDragging = false;
        hideTooltip();
    }

    function normalizeLng(lng) {
        while (lng > 180) lng -= 360;
        while (lng < -180) lng += 360;
        return lng;
    }

    function onWheel(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const targetLatLng = pixelToLatLng(mouseX, mouseY);

        let targetLng = targetLatLng.lng;
        while (targetLng - viewCenter[1] > 180) targetLng -= 360;
        while (targetLng - viewCenter[1] < -180) targetLng += 360;
        targetLatLng.lng = targetLng;

        const delta = e.deltaY > 0 ? -0.5 : 0.5;
        const newZoom = Math.max(1, Math.min(20, viewZoom + delta));
        if (newZoom === viewZoom) return;

        viewZoom = newZoom;

        const canvasWidth = canvas.width / window.devicePixelRatio;
        const canvasHeight = canvas.height / window.devicePixelRatio;
        const scale = Math.pow(2, viewZoom) * TILE_SIZE;

        const targetWorldX = (targetLatLng.lng + 180) / 360 * scale;
        const targetLatRad = targetLatLng.lat * Math.PI / 180;
        const targetWorldY = (1 - Math.log(Math.tan(targetLatRad) + 1 / Math.cos(targetLatRad)) / Math.PI) / 2 * scale;

        const newCenterWorldX = targetWorldX - mouseX + canvasWidth / 2;
        const newCenterWorldY = targetWorldY - mouseY + canvasHeight / 2;

        let newCenterLng = newCenterWorldX / scale * 360 - 180;
        const n = Math.PI - 2 * Math.PI * newCenterWorldY / scale;
        let newCenterLat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));

        newCenterLat = Math.max(-85, Math.min(85, newCenterLat));
        newCenterLng = normalizeLng(newCenterLng);

        viewCenter = [newCenterLat, newCenterLng];

        render();
    }

    let touchStartDist = null;
    let touchStartZoom = null;

    function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            isDragging = true;
            dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            dragCenterStart = [...viewCenter];
        } else if (e.touches.length === 2) {
            isDragging = false;
            touchStartDist = getTouchDistance(e.touches);
            touchStartZoom = viewZoom;
        }
    }

    function onTouchMove(e) {
        e.preventDefault();
        if (e.touches.length === 1 && isDragging && dragStart) {
            const dx = e.touches[0].clientX - dragStart.x;
            const dy = e.touches[0].clientY - dragStart.y;

            const startLatLng = pixelToLatLng(canvas.width / 2 / window.devicePixelRatio, canvas.height / 2 / window.devicePixelRatio);
            const endLatLng = pixelToLatLng(canvas.width / 2 / window.devicePixelRatio - dx, canvas.height / 2 / window.devicePixelRatio - dy);

            viewCenter = [
                dragCenterStart[0] - (endLatLng.lat - startLatLng.lat),
                dragCenterStart[1] - (endLatLng.lng - startLatLng.lng)
            ];
            render();
        } else if (e.touches.length === 2 && touchStartDist) {
            const dist = getTouchDistance(e.touches);
            const scale = dist / touchStartDist;
            setZoom(touchStartZoom + Math.log2(scale));
        }
    }

    function onTouchEnd() {
        isDragging = false;
        dragStart = null;
        touchStartDist = null;
    }

    function getTouchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function setZoom(z) {
        viewZoom = Math.max(1, Math.min(20, z));
        render();
    }

    function fitBounds() {
        if (!dataBounds) return;

        viewCenter = [
            (dataBounds.min_lat + dataBounds.max_lat) / 2,
            (dataBounds.min_lng + dataBounds.max_lng) / 2
        ];
        viewZoom = initialZoom;
        render();
    }

    // Tooltip
    function updateTooltip(x, y) {
        let found = null;
        let foundType = null;

        for (let i = mapData.points.length - 1; i >= 0; i--) {
            const point = mapData.points[i];
            const pos = latlngToPixel(point.lat, point.lng);
            const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
            if (dist <= point.style.radius + 3) {
                found = point;
                foundType = 'point';
                break;
            }
        }

        if (!found) {
            for (let i = mapData.lines.length - 1; i >= 0; i--) {
                const line = mapData.lines[i];
                if (isPointNearLine(x, y, line)) {
                    found = line;
                    foundType = 'line';
                    break;
                }
            }
        }

        if (!found) {
            for (let i = mapData.polygons.length - 1; i >= 0; i--) {
                const polygon = mapData.polygons[i];
                if (isPointInPolygon(x, y, polygon)) {
                    found = polygon;
                    foundType = 'polygon';
                    break;
                }
            }
        }

        if (found) {
            showTooltip(x, y, found, foundType);
        } else {
            hideTooltip();
        }
    }

    function isPointNearLine(px, py, line) {
        const tolerance = line.style.stroke_width / 2 + 5;

        for (let i = 0; i < line.coords.length - 1; i++) {
            const p1 = latlngToPixel(line.coords[i][0], line.coords[i][1]);
            const p2 = latlngToPixel(line.coords[i + 1][0], line.coords[i + 1][1]);

            const dist = pointToSegmentDistance(px, py, p1.x, p1.y, p2.x, p2.y);
            if (dist <= tolerance) return true;
        }
        return false;
    }

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len2 = dx * dx + dy * dy;

        if (len2 === 0) return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));

        let t = ((px - x1) * dx + (py - y1) * dy) / len2;
        t = Math.max(0, Math.min(1, t));

        const nearX = x1 + t * dx;
        const nearY = y1 + t * dy;

        return Math.sqrt(Math.pow(px - nearX, 2) + Math.pow(py - nearY, 2));
    }

    function isPointInPolygon(px, py, polygon) {
        if (polygon.rings.length === 0) return false;

        const pixelRings = polygon.rings.map(ring =>
            ring.map(coord => latlngToPixel(coord[0], coord[1]))
        );

        if (!pointInRing(px, py, pixelRings[0])) return false;

        for (let i = 1; i < pixelRings.length; i++) {
            if (pointInRing(px, py, pixelRings[i])) return false;
        }

        return true;
    }

    function pointInRing(px, py, ring) {
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            const xi = ring[i].x, yi = ring[i].y;
            const xj = ring[j].x, yj = ring[j].y;

            if (((yi > py) !== (yj > py)) &&
                (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    function showTooltip(x, y, feature, type) {
        const style = feature.style;
        const fields = style.tooltip_fields;
        const template = style.tooltip_template;
        const properties = feature.properties;

        if (!fields && !template) {
            hideTooltip();
            return;
        }

        let html = '';

        if (template) {
            html = template.replace(/\{(\w+)\}/g, (_, key) => {
                return properties[key] != null ? escapeHtml(String(properties[key])) : '';
            });
        } else if (fields) {
            for (const field of fields) {
                if (properties[field] != null) {
                    html += '<div class="tooltip-row">';
                    html += '<span class="tooltip-field">' + escapeHtml(field) + ':</span> ';
                    html += '<span class="tooltip-value">' + escapeHtml(String(properties[field])) + '</span>';
                    html += '</div>';
                }
            }
        }

        if (!html) {
            hideTooltip();
            return;
        }

        tooltip.innerHTML = html;
        tooltip.classList.add('visible');

        const rect = container.getBoundingClientRect();
        let left = x + 15;
        let top = y + 15;

        if (left + tooltip.offsetWidth > rect.width - 10) {
            left = x - tooltip.offsetWidth - 10;
        }
        if (top + tooltip.offsetHeight > rect.height - 10) {
            top = y - tooltip.offsetHeight - 10;
        }

        tooltip.style.left = Math.max(5, left) + 'px';
        tooltip.style.top = Math.max(5, top) + 'px';
    }

    function hideTooltip() {
        tooltip.classList.remove('visible');
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    window.pixelToLatLng = pixelToLatLng;
    window.latlngToPixel = latlngToPixel;
    window.render = render;
    window.mapData = mapData;
    window.canvas = canvas;
    window.getViewCenter = () => [...viewCenter];
    window.setViewCenter = (lat, lng) => { viewCenter[0] = lat; viewCenter[1] = lng; };
    window.getViewZoom = () => viewZoom;
    window.setViewZoom = (z) => { viewZoom = z; };

    Object.defineProperty(window, 'viewCenter', {
        get: () => viewCenter,
        set: (v) => { viewCenter[0] = v[0]; viewCenter[1] = v[1]; },
        configurable: true
    });
    Object.defineProperty(window, 'viewZoom', {
        get: () => viewZoom,
        set: (v) => { viewZoom = v; },
        configurable: true
    });

    init();
})();
    </script>
</body>
</html>